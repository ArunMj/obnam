#!/usr/bin/env python
#
# Copyright 2014  Lars Wirzenius
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


import json
import os
import shutil
import sys
import tempfile
import time

import cliapp
import Crypto.Cipher.ARC4


class BinaryJunkGenerator(object):

    key = b'obnam-benchmark'
    data = b'fake live data' * 1024

    def __init__(self):
        self.cipher = Crypto.Cipher.ARC4.new(self.key)
        self.buffer = ''

    def get(self, num_bytes):
        n = 0
        result = []
        while n < num_bytes:
            if not self.buffer:
                self.buffer = self.cipher.encrypt(self.data)

            part = self.buffer[:num_bytes - n]
            result.append(part)
            n += len(part)
            self.buffer = self.buffer[len(part):]

        return ''.join(result)


class Measurer(object):

    def __init__(self, label, filename):
        self.filename = filename
        self.measurements = {
            'label': label,
            }

    def __enter__(self):
        self.start = time.time()
        return self.measurements

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is None:
            end = time.time()
            self.measurements['duration'] = end - self.start
            with open(self.filename, 'w') as f:
                json.dump(self.measurements, f)
        return False


class ObnamBenchmark(object):

    def __init__(self, settings, junk_generator):
        self.settings = settings
        self.junk_generator = junk_generator

    @classmethod
    def add_settings(self, settings):
        pass

    @property
    def benchmark_name(self):
        return self.__class__.__name__

    def result_filename(self, label, suffix):
        return os.path.join(
            self.results,
            '%s-%s%s' % (self.benchmark_name, label, suffix))

    def run(self):
        self.tempdir = tempfile.mkdtemp()
        self.live_data = self.create_live_data_dir()
        self.repo = self.create_repo()
        self.results = self.create_results_dir()

        print '  create live data'
        self.create_live_data()

        print '  initial backup'
        self.backup('initial-backup')

        print '  no-op second backup'
        self.backup('no-op-backup')

        print '  obnam restore'
        self.restore_with_obnam_restore()

        print '  obnam mount && cp restore'
        self.restore_with_obnam_mount()

        print '  cleanup'
        shutil.rmtree(self.tempdir)

    def create_live_data(self):
        # Subclasses MUST override this.
        raise NotImplementedError()

    def create_live_data_dir(self):
        live_data = os.path.join(self.tempdir, 'live-data')
        os.mkdir(live_data)
        return live_data

    def create_repo(self):
        repo = os.path.join(self.tempdir, 'repo')
        os.mkdir(repo)
        return repo

    def create_results_dir(self):
        results = self.settings['results-dir']
        if not os.path.exists(results):
            os.mkdir(results)
        return results

    def backup(self, label):
        with Measurer(label, self.result_filename(label, '.json')):
            self.run_obnam(['backup', '-r', self.repo, self.live_data], label)

    def restore_with_obnam_restore(self):
        restored = os.path.join(self.tempdir, 'restored')
        os.mkdir(restored)
        label = 'obnam-restore'
        with Measurer(label, self.result_filename(label, '.json')):
            self.run_obnam(
                ['restore', '-r', self.repo, '--to', restored],
                label)
        shutil.rmtree(restored)

    def restore_with_obnam_mount(self):
        mount = os.path.join(self.tempdir, 'mount')
        os.mkdir(mount)

        restored = os.path.join(self.tempdir, 'restored')
        os.mkdir(restored)

        label = 'obnam-mount'
        self.run_obnam(
            ['mount', '-r', self.repo, '--to', mount],
            label)
        with Measurer(label, self.result_filename(label, '.json')):
            cliapp.runcmd(['cp', '-a', mount + '/.', restored + '/.'])
        cliapp.runcmd(['fusermount', '-u', mount])

        shutil.rmtree(restored)
        os.rmdir(mount)

    def run_obnam(self, args, label):
        base_command = [
            './obnam',
            '--no-default-config',
            '--log', self.result_filename(label, '.log'),
            '--log-level', 'debug',
            ]
        env = dict(os.environ)
        env['OBNAM_PROFILE'] = self.result_filename(label, '.prof')
        cliapp.runcmd(base_command + args, env=env)


class EmptyFilesBenchmark(ObnamBenchmark):

    files_per_dir = 1000

    @classmethod
    def add_settings(self, settings):
        settings.integer(
            ['empty-files-count'],
            'number of empty files for %s' % self.__class__.__name__,
            default=10**6)

    @property
    def num_files(self):
        return self.settings['empty-files-count']

    def create_live_data(self):
        for i in range(self.num_files):
            subdir = os.path.join(
                self.live_data, 'dir-%d' % (i / self.files_per_dir))
            if (i % self.files_per_dir) == 0:
                os.mkdir(subdir)
            filename = os.path.join(subdir, 'file-%d' % i)
            with open(filename, 'w'):
                pass


class SingleLargeFileBenchmark(ObnamBenchmark):

    file_size = 2**3

    @classmethod
    def add_settings(self, settings):
        settings.bytesize(
            ['single-large-file-size'],
            'size of file to create for %s' % self.__class__.__name__,
            default='1TB')

    def create_live_data(self):
        filename = os.path.join(self.live_data, 'file.dat')
        with open(filename, 'w') as f:
            for i in range(self.file_size):
                f.write(self.junk_generator.get(1))


class ObnamBenchmarkRunner(cliapp.Application):

    benchmark_classes = [
        EmptyFilesBenchmark,
        SingleLargeFileBenchmark,
        ]

    def add_settings(self):
        self.settings.string(
            ['results-dir'],
            'put results in DIR',
            metavar='DIR',
            default='.')

        for benchmark_class in self.benchmark_classes:
            benchmark_class.add_settings(self.settings)

    def process_args(self, args):
        junk_generator = BinaryJunkGenerator()
        for benchmark_class in self.benchmark_classes:
            print 'Benchmark %s' % benchmark_class.__name__
            benchmark = benchmark_class(self.settings, junk_generator)
            benchmark.run()


if __name__ == '__main__':
    ObnamBenchmarkRunner().run()

