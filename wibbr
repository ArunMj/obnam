#!/usr/bin/python


import ConfigParser
import optparse
import os
import stat
import subprocess
import sys

from wibbrlib.object import *
import wibbrlib.backend
import wibbrlib.cache
import uuid


def default_config():
    items = (
        ("wibbr", "block-cache", "block-cache"),
        ("wibbr", "block-size", "%d" % (64 * 1024)),
        ("local-backend", "root", "block-store"),
    )
    
    config = ConfigParser.ConfigParser()
    for section, item, value in items:
        if not config.has_section(section):
            config.add_section(section)
        config.set(section, item, value)

    if "WIBBR_BLOCK_SIZE" in os.environ:
        config.set("wibbr", "block-size", os.environ["WIBBR_BLOCK_SIZE"])
    
    return config


def new_object_id():
    return str(uuid.uuid4())


class Map:

    def __init__(self, be):
        self.dict = {}
        self.be = be
        self.new_block()
        
    def new_block(self):
        self.next_block_id = wibbrlib.backend.generate_block_id(self.be)
        
    def add(self, objid):
        if objid in self.dict:
            self.dict[objid].append(self.next_block_id)
        else:
            self.dict[objid] = [self.next_block_id]


def write_block(be, id, oq):
    block = block_create_from_object_queue(id, oq)
    assert type(block) == type("")
    wibbrlib.backend.upload(be, id, block)


def enqueue_object(config, be, map, oq, id, object):
    block_size = config.getint("wibbr", "block-size")
    if len(object) + object_queue_combined_size(oq) > block_size:
        write_block(be, map.next_block_id, oq)
        map.new_block()
        oq = object_queue_create()
    object_queue_add(oq, object)
    map.add(id)
    return oq


def create_file_contents_object(config, be, map, oq, filename):
    id = new_object_id()
    block_size = config.getint("wibbr", "block-size")
    f = file(filename, "r")
    while True:
        data = f.read(block_size)
        if not data:
            break
        c = component_encode(CMP_FILEDATA, data)
        o = object_encode(id, OBJ_FILECONT, [c])
        oq = enqueue_object(config, be, map, oq, id, o)
    f.close()
    return id, oq


def create_signature_object(config, be, map, oq, filename):
    id = new_object_id()
    p = subprocess.Popen(["rdiff", "signature", "--", filename],
                         stdout=subprocess.PIPE)
    (sigdata, _) = p.communicate()
    c = component_encode(CMP_SIGDATA, sigdata)
    o = object_encode(id, OBJ_SIG, [c])
    oq = enqueue_object(config, be, map, oq, id, o)
    return id, oq


def create_inode_object(config, be, map, oq, filename, sig_id, cont_id):
    st = os.stat(filename)
    nst = normalize_stat_result(st)
    id = new_object_id()
    o = inode_object_encode(id, nst, sig_id, cont_id)
    return id, enqueue_object(config, be, map, oq, id, o)


def back_up_directory(config, be, map, oq, dirname):
    pairs = []
    for dirpath, dirnames, filenames in os.walk(dirname):
        for filename in filenames:
            filename = os.path.join(dirpath, filename)
            st = os.lstat(filename)
            if stat.S_ISREG(st.st_mode):
                (cont_id, oq) = \
                    create_file_contents_object(config, be, map, oq, filename)
                (sig_id, oq) = \
                    create_signature_object(config, be, map, oq, filename)
                (inode_id, oq) = \
                    create_inode_object(config, be, map, oq, filename, sig_id, 
                                        cont_id)
                pairs.append((filename, inode_id))
    genid = new_object_id()
    gen = generation_object_encode(genid, pairs)
    oq = enqueue_object(config, be, map, oq, genid, gen)
    return oq


def parse_options(config, argv):
    parser = optparse.OptionParser()

    parser.add_option("--cache-dir", 
                      metavar="DIR",
                      help="Use DIR as block cache directory")

    parser.add_option("--block-size",
                      type="int",
                      metavar="SIZE",
                      help="Block size (in kilobytes)")

    parser.add_option("--block-store",
                      metavar="DIR",
                      help="Store blocks in DIR")

    (options, args) = parser.parse_args(argv)
    
    if options.cache_dir:
        config.set("wibbr", "block-cache", options.cache_dir)
    if options.block_size:
        config.set("wibbr", "block-size", options.block_size * 1024)
    if options.block_store:
        config.set("local-backend", "root", options.block_store)


def main():
    config = default_config()
    
    parse_options(config, sys.argv[1:])
    
    cache = wibbrlib.cache.init(config)
    be = wibbrlib.backend.init(config, cache)

    map = Map(be)
    oq = object_queue_create()

    for dirname in sys.argv[1:]:
        oq = back_up_directory(config, be, map, oq, dirname)

    if object_queue_combined_size(oq) > 0:
        write_block(be, map.next_block_id, oq)
        map.new_block()
        del oq

    mapq = object_queue_create()
    for objid in map.dict:
        data = objid + "".join(map.dict[objid])
        c = component_encode(CMP_OBJMAP, data)
        object_queue_add(mapq, c)
    mapid = wibbrlib.backend.generate_block_id(be)
    write_block(be, mapid, mapq)


if __name__ == "__main__":
    main()
