#!/usr/bin/python


import ConfigParser
import os
import stat
import subprocess
import sys

from wibbrlib import *
import backend
import uuid


def default_config():
    items = (
        ("wibbr", "block-cache", "block-cache"),
        ("wibbr", "block-size", "%d" % (64 * 1024)),
        ("local-backend", "root", "block-store"),
    )
    
    config = ConfigParser.ConfigParser()
    for section, item, value in items:
        if not config.has_section(section):
            config.add_section(section)
        config.set(section, item, value)

    if "WIBBR_BLOCK_SIZE" in os.environ:
        config.set("wibbr", "block-size", os.environ["WIBBR_BLOCK_SIZE"])
    
    return config


def new_id():
    return str(uuid.uuid4())


class Map:

    def __init__(self):
        self.new_block()
        self.dict = {}
        
    def new_block(self):
        self.next_block_id = new_id()
        
    def add(self, objid):
        if objid in self.dict:
            self.dict[objid].append(self.next_block_id)
        else:
            self.dict[objid] = [self.next_block_id]


def write_block(be, id, oq):
    block = block_create_from_object_queue(id, oq)
    assert type(block) == type("")
    backend.upload(be, id, block)


def enqueue_object(config, map, oq, id, object):
    block_size = config.getint("wibbr", "block-size")
    if len(object) + object_queue_combined_size(oq) > block_size:
        write_block(map.next_block_id, oq)
        map.new_block()
        oq = object_queue_create()
    object_queue_add(oq, object)
    map.add(id)
    return oq


def create_file_contents_object(map, oq, filename):
    id = new_id()
    block_size = config.getint("wibbr", "block-size")
    f = file(filename, "r")
    while True:
        data = f.read(block_size)
        if not data:
            break
        c = component_encode(CMP_FILEDATA, data)
        o = object_encode(id, OBJ_FILECONT, [c])
        oq = enqueue_object(config, map, oq, id, o)
    f.close()
    return id, oq


def create_signature_object(map, oq, filename):
    id = new_id()
    p = subprocess.Popen(["rdiff", "signature", "--", filename],
                         stdout=subprocess.PIPE)
    (sigdata, _) = p.communicate()
    c = component_encode(CMP_SIGDATA, sigdata)
    o = object_encode(id, OBJ_SIG, [c])
    oq = enqueue_object(config, map, oq, id, o)
    return id, oq


def create_inode_object(map, oq, filename, sig_id, cont_id):
    st = os.stat(filename)
    nst = normalize_stat_result(st)
    id = new_id()
    o = inode_object_encode(id, nst, sig_id, cont_id)
    return id, enqueue_object(config, map, oq, id, o)


def back_up_directory(config, be, map, oq, dirname):
    pairs = []
    for dirpath, dirnames, filenames in os.walk(dirname):
        for filename in filenames:
            filename = os.path.join(dirpath, filename)
            st = os.lstat(filename)
            if stat.S_ISREG(st.st_mode):
                (cont_id, oq) = create_file_contents_object(map, oq, filename)
                (sig_id, oq) = create_signature_object(map, oq, filename)
                (inode_id, oq) = create_inode_object(map, oq, filename,
                                                     sig_id, cont_id)
                pairs.append((filename, inode_id))
    genid = new_id()
    gen = generation_object_encode(genid, pairs)
    oq = enqueue_object(config, map, oq, genid, gen)
    return oq


def main():
    config = default_config()
    be = backend.init(config)

    map = Map()
    oq = object_queue_create()

    for dirname in sys.argv[1:]:
        oq = back_up_directory(config, be, map, oq, dirname)

    if object_queue_combined_size(oq) > 0:
        write_block(be, map.next_block_id, oq)
        map.new_block()
        del oq

    mapq = object_queue_create()
    for objid in map.dict:
        data = objid + "".join(map.dict[objid])
        c = component_encode(CMP_OBJMAP, data)
        object_queue_add(mapq, c)
    mapid = new_id()
    write_block(be, mapid, mapq)

if __name__ == "__main__":
    main()
