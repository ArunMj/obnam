Obnam Storage Design
====================

:Author: Lars Wirzenius
:Date: 2008-01-06



Introduction
------------

This paper describes the storage structure for Obnam, a backup system.
The backups are done over a network to an SFTP server, or other server
of similar complexity. The server does not have any understanding of
what the data is, it just stores it. The backups are encrypted and
signed by the client to ensure they remain confidential and valid.



General requirements
--------------------

The storage structure must fill the following requirements:

* Avoid downloading files from the server in normal operation. Downloading
  takes time and the bandwidth may be metered by the byte.

* Avoid storing excessive amounts of data on the client.

* Avoid transferring or storing very large or very small files. Large
  transfers are more likely to be interrupted, and it may not be possible
  to continue them. Small transfers cause connection setup overhead to
  become significant. The remote filesystem may have limits on maximum
  file size, and may have a large block size, meaning that a small file
  will still use up an entire block.

* Avoid keeping lots of data in memory on the client. This is necessary
  to support small-memory systems.
  
* Support snapshots of a current backup while it is in progress. When
  a new generation (usually the first generation) is very big, it is
  good to have a snapshot of the progress every now and then. This way,
  if the backup run is terminated in the middle, all work is not lost.
  The overhead of such a snapshot should be small.

* Keep the per-generation overhead small. It should be proportional to
  the delta from the previous generation: number of files affected and
  the amount of data affected.


Historical note
---------------

In version 0.9.x, we introduced a new way of storing the metadata of a
file in a better way. Metadata includes filenames, and inode data, and
basically everything except the contents of a file.

In the old way, all the metadata for files belonging to a generation was
stored in an object called FILELIST. In the new way, we build a tree
mirroring the filesystem, using objects called DIR and FILEGROUP. We
keep the ability to read FILELIST objects, but no longer include code
to generate them.

The point of the new way is to allow re-use of parts of the directory
tree that are not changed in a new generation. This reduces the
per-generation overhead drastically, allows efficient snapshotting in
the middle of a backup run, and reducing the amount of data we keep in
memory at a time.
  

Logical and physical structures
-------------------------------

Data is stored in the backup storage in a two-level structure: the
"logical structure" and the "physical structure". The logical structure
concerns itself with storing the data and metadata of files, and keeping
track of which version of which file belongs to which generations of
backups. The physical structure stores the information in the logical
structure in actual files on the backup server.



The logical structure
---------------------

The logical structure consists of a number of "storage objects" arranged
into a directed acyclic graph (DAG). The root of the DAG is a "host
object", which is (in essence) a list of backup generations.

Each generation is represented by its own "generation object", and
consists of a set of references to files and directories (FILEGROUP and
DIR objects). A DIR is a similar set. We thus get tree such as the
following one:

    HOST                            -- the root object, which contains
        GEN                         -- one generation, which contains
            FILEGROUP               -- two groups of files, plus...
            FILEGROUP
            DIR                     -- two directories, the first one
                FILEGROUP           -- containing one group of files and
                DIR                 -- three empty subdirectories
                DIR
                DIR
            DIR                     -- and the other two groups of files
                FILEGROUP
                FILEGROUP
                DIR                 -- and one subdirectory, with one
                    FILEGROUP       -- group of files
                    
A FILEGROUP is just a list of basenames for non-directories (regular
files, symlinks, device files, etc), plus their associated inode data
(permissions, ownerships, etc). We group files into groups this way
for efficiency: otherwise there would be a very large number of storage
objects for them, and that would be an unbearable overhead. The grouping
is arbitrary, except that all files in a group are assumed to be in the
same directory. Hard links are stored once per link. The number of
files in a group is determined (by guessing) to be large enough to keep
the number of storage objects small, and small enough that there is no
need to split them up very often.

A DIR holds the name and other metadata for a directory, similar to
files in a FILEGROUP, and sets of references to FILEGROUPs (for files
in that directory) and other DIRs (for subdirectories).

Filenames are just string objects, but the inode data is a further
object that consists of the file metadata in the filesystem inode, and a
reference to the rsync signature object, and finally either a reference
to an object containing the entire contents of the file, or a reference
to the delta object.

The signature object contains the rsync block signatures. The file
contents object contains the entire contents of the file. The delta
object contains the rsync delta (all the changes from a previous version
of the file), plus a reference to the delta or file contents object from
which the delta was computed.

Note that multiple inodes may refer to the same signature, file
contents, and delta objects. This way, we can store identical copies of
the same data only once.



The physical structure
----------------------

At the physical level the backup storage is divided into a number of
files which we will call blocks. Each block file attempts to be of a
uniform size (user adjustable, but let's assume one megabyte for now).
If it does not manage to be exactly that size, that is not a problem as
such, but the goal is to be near the size. A uniform size gives less
information to an attacker.

Each block contains one or more storage objects from the logical level,
or parts of them, for objects that are bigger than the target size of a
block. To make it quick to find which block or blocks contain an object,
there are special blocks that contain a mapping between object
identifiers to block identifiers.

A block is divided into "components", which contain three fields: size,
kind, and contents. The size field gives the size of the data field, and
kind gives its meaning. Components may contain other components in the
data field.



Initializing the backup store for a host
----------------------------------------

To initialize the backup store for a host, you create the host
object/block. This requires creating a unique host identifier (hostname
is used by default), and filling in the fields in the objects, and then
uploading it. You store the host object's id on the client, in the
host-id setting in the configuration file.

In the case of a complete disaster, where the host UUID gets lost, you
scan all blocks to find the host block that refers to the client you're
interested in. Note that there might be several host blocks in the same
server account, referring to different client computers.



Adding a backup generation
--------------------------

To add a new backup generation, you scan the filesystem for all files.
For each file, you see if you can re-use the inode, signature, or
contents/delta, and if not, you create new ones. You create the list of
files and inode references into a new generation. You put all the new
objects into blocks and upload the blocks to the server, then update the
host block and upload that.



Forgetting (removing) generations
---------------------------------

To forget one or more generations, you first create a new host block
that drops the unwanted generations from the list of generations. Then
you get a list of all block files, and go through the DAG and mark all
the blocks that are still being used. Then you delete the block files
that are no longer being used.

Note that this requires some thought if there is a need to allow several
client hosts to share a backup server account. When creating the list of
all blocks, you should ignore blocks not belonging to your client. If
the server is an FTP server, creating a per-host directory would work.

Note that the server may contain blocks that are lost due to the client
forgetting about a half-finished transaction; see the previous section,
"Adding a backup generation". These blocks should probably also be
removed during a forgetting operation, at least the option to do so
should be given.


Basic data types
-----------------

There are two basic types of data stored in the backups: integers and
strings.

Integers are non-negative arbitrarily big integers (as far as the storage
format is concerned). They are encoded in storage as a sequence of bytes
giving ASCII digits, followed by a newline. For example, the value 42
would be encoded as the bytes 0x34, 0x32, 0x0a, in that order.

Strings are just sequences of bytes (octets). Depending on circumstance,
they may be interpreted as, say, UTF-8 filenames.


Block representation
--------------------

A block starts with the magic cookie "blockhead\n" in ASCII encoding
(with the "\n" indicating a newline character). After that a series of
encoded components, one of which is a BLKID component, giving the
identifier for the block (typically also part of its name).


Objects
-------

Objects consist of an integer kind, a string identifier, and some
sequence of components. Depending on the kind, the components differ.

The objects in backup storage look like below. A "*" is used to indicate
repetition (zero or more instances). A "?" is used to indicate optional
components. Order of consecutive components of the same type is often
significant.

    HOST object
        OBJID
        OBJKIND
        FORMATVERSION
        GENREF* (oldest first)
        MAPREF*
        CONTMAPREF*

    GEN object
        OBJID
        OBJKIND
        FILELISTREF?        -- either exactly one FILELISTREF or
        DIRREF*             -- at least one of DIRREF/FILEGROUPREF
        FILEGROUPREF*       -- (but any number of those)
        GENSTART
        GENEND

    FILELIST
        FILE*
            FILENAME
            STAT -- specially encoded component with struct stat fields
            CONTREF? -- either this or DELTAREF must be there
            SIGREF?
            DELTAREF?

    DIR
        FILENAME
        STAT
        DIRREF*
        FILEGROUPREF*
        
    FILEGROUP
        FILE*
            FILENAME
            STAT -- specially encoded component with struct stat fields
            CONTREF? -- either this or DELTAREF must be there
            SIGREF?
            DELTAREF?

    SIG object
        OBJID
        OBJKIND
        SIGDATA

    DELTA object
        OBJID
        OBJKIND
        DELTAPARTREFS* -- in order
        CONTREF? -- this or DELTAREF must exist
        DELTAREF?

    DELTAPART object
        OBJID
        OBJKIND
        DELTADATA

    FILECONTENTS object
        OBJID
        OBJKIND
        FILEPARTREF*
        
    FILEPART object
        OBJID
        OBJKIND
        FILECHUNK

    OBJMAP component (at block level)
        -- lists which objects exist in each block
        BLOCKREF -- the block id
        OBJREF* -- list of objects in that block


Components
----------

Both objects and blocks consist of some number of components. Each
component consists of three fields: size, kind, and data. The size and
kind are integers, encoded as variable integers as described above.
The data is one of: raw binary string, a variable integer, or a
sequence of components. What the data is can be deduced from the kind
of the component.

Below is a list of all component kinds, including a description. Components
that reference a block or object use the UUID to do it.

    Kind        Code    Data        Description
    -------------------------------------------------------------------------
    OBJID       1       string      The UUID for an object.
    OBJKIND     2       int         The kind of an object.
    BLKID       3       string      The UUID for a block.
    FILECHUNK   4       string      A part of the contents of a file.
    OBJECT      5       n/a         A block-level component that contains 
                                    an object.
    OBJMAP      6       n/a         Mapping of object ids to block id (all 
                                    the objects inside one block go into one 
                                    OBJMAP)
    CONTREF     20      string      Reference to a FILECONTENTS object.
    NAMEIPAIR   21      n/a         A pair of INODEREF and FILENAME.
    FILENAME    23      string      A file's name.
    SIGDATA     24      string      Rsync signature data for a file.
    SIGREF      25      string      A reference to a SIG object.
    GENREF      26      string      A reference to a GEN object.
    OBJREF      28      string      A reference to any kind of object (for 
                                    OBJMAP components).
    BLOCKREF    29      string      A reference to a block.
    MAPREF      30      string      A reference to a map block (block 
                                    containing only OBJMAP components).
    FILEPARTREF 31      string      A reference to a FILEPART object.
    FORMATVERSION 32    string      Version of the storage format.
    FILE        33      n/a         Meta data about a file.
    FILELISTREF 34      string      A reference to a FILELIST object.
    CONTMAPREF  35      string      A reference to a CONTMAP object.
    DELTAREF    36      string      A reference to a DELTA object.
    DELTADATA   37      string      Partial rsync delta data for a file.
    STAT        38      n/a         struct stat data, specially encoded.
    GENSTART    39      integer     A generation's starting timestamp.
    GENEND      40      integer     A generation's ending timestamp.
    DELTAPARTREF 41     string      A reference to a DELTAPART object.

The actual code for a kind is the number from the table above, shifted
two bits up, and with the new lowest two bits used for flags: 0x01 for
"composite component", and 0x02 for "reference component".

The STAT component is encoded specially, for speed. It is a sequence of
variable length integers, for the following fields in a struct stat:
st_mode, st_ino, st_dev, st_nlink, st_uid, st_gid, st_size, st_atime,
st_mtime, st_ctime, st_blocks, st_blksize, st_rdev. An approach for
using components, as for everything else, would have been nice, but
proved to be pretty slow.


Legalese
--------

Copyright 2007, 2008 Lars Wirzenius

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
