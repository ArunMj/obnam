# Copyright 2010  Lars Wirzenius
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


'''Test paramiko by doing an sftp copy from localhost.'''


import os
import paramiko
import pwd
import subprocess
import sys
import tempfile
import time


import weakref
_subproc_weakrefs = set()


def _ignore_sigint():
    # TODO: This should possibly ignore SIGHUP as well, but bzr currently
    # doesn't handle it itself.
    # <https://launchpad.net/products/bzr/+bug/41433/+index>
    import signal
    signal.signal(signal.SIGINT, signal.SIG_IGN)


def os_specific_subprocess_params():
    """Get O/S specific subprocess parameters."""
    if sys.platform == 'win32':
        # setting the process group and closing fds is not supported on
        # win32
        return {}
    else:
        # We close fds other than the pipes as the child process does not need
        # them to be open.
        #
        # We also set the child process to ignore SIGINT.  Normally the signal
        # would be sent to every process in the foreground process group, but
        # this causes it to be seen only by bzr and not by ssh.  Python will
        # generate a KeyboardInterrupt in bzr, and we will then have a chance
        # to release locks or do other cleanup over ssh before the connection
        # goes away.
        # <https://launchpad.net/products/bzr/+bug/5987>
        #
        # Running it in a separate process group is not good because then it
        # can't get non-echoed input of a password or passphrase.
        # <https://launchpad.net/products/bzr/+bug/40508>
        return {'preexec_fn': _ignore_sigint,
                'close_fds': True,
                }


class SSHSubprocess(object):
    """A socket-like object that talks to an ssh subprocess via pipes."""

    def __init__(self, proc):
        self.proc = proc
        # Add a weakref to proc that will attempt to do the same as self.close
        # to avoid leaving processes lingering indefinitely.
        def terminate(ref):
            _subproc_weakrefs.remove(ref)
            _close_ssh_proc(proc)
        _subproc_weakrefs.add(weakref.ref(self, terminate))

    def send(self, data):
        return os.write(self.proc.stdin.fileno(), data)

    def recv(self, count):
        return os.read(self.proc.stdout.fileno(), count)

    def close(self):
        _close_ssh_proc(self.proc)

    def get_filelike_channels(self):
        return (self.proc.stdout, self.proc.stdin)


class SocketAsChannelAdapter(object):
    """Simple wrapper for a socket that pretends to be a paramiko Channel."""

    def __init__(self, sock):
        self.__socket = sock

    def get_name(self):
        return "bzr SocketAsChannelAdapter"

    def send(self, data):
        return self.__socket.send(data)

    def recv(self, n):
        try:
            return self.__socket.recv(n)
        except socket.error, e:
            if e.args[0] in (errno.EPIPE, errno.ECONNRESET, errno.ECONNABORTED,
                             errno.EBADF):
                # Connection has closed.  Paramiko expects an empty string in
                # this case, not an exception.
                return ''
            raise

    def recv_ready(self):
        # TODO: jam 20051215 this function is necessary to support the
        # pipelined() function. In reality, it probably should use
        # poll() or select() to actually return if there is data
        # available, otherwise we probably don't get any benefit
        return True

    def close(self):
        self.__socket.close()



username = pwd.getpwuid(os.getuid()).pw_name
host = 'localhost'
port = 22
path = '/tmp/zeroes'

if False:
    transport = paramiko.Transport((host, port))
    transport.connect()
    agent = paramiko.Agent()
    agent_keys = agent.get_keys()
    for key in agent_keys:
        try:
            transport.auth_publickey(username, key)
            break
        except paramiko.SSHException:
            pass
    else:
        raise Exception('no auth')
    sftp = paramiko.SFTPClient.from_transport(transport)
else:
    subsystem = 'sftp'
    args = ['ssh',
            '-oForwardX11=no', '-oForwardAgent=no',
            '-oClearAllForwardings=yes', '-oProtocol=2',
            '-oNoHostAuthenticationForLocalhost=yes']
    if port is not None:
        args.extend(['-p', str(port)])
    if username is not None:
        args.extend(['-l', username])
    args.extend(['-s', host, subsystem])

    proc = subprocess.Popen(args,
                            stdin=subprocess.PIPE,
                            stdout=subprocess.PIPE,
                            **os_specific_subprocess_params())
    sock = SSHSubprocess(proc)
    
    sftp = paramiko.SFTPClient(SocketAsChannelAdapter(sock))


n = 0
f = sftp.open(path)
start = time.time()
while True:
    data = f.read(32*1024)
    if not data:
        break
    n += len(data)
end = time.time()

duration = end - start
n = float(n)
print duration, n/1024/1024, 8 * n / duration / 1024 / 1024
