Test implementation
===================

This chapter documents the generic, shared IMPLEMENTS sections for
steps that are used in a variety of scenarios. It also discusses the
shell library that may be used by all IMPLEMENTS sections.

The shell library
-----------------

The shell library contains shell functions and sets some shell
variables that can be used by any IMPLEMENTS sections.

Variables:

* `LIVEDATA`: the pathname of the directory where live data is stored
  (for single-client scenarios).
* `REPO`: the pathname of the backup repository.

Functions:

* `run_obnam`: run Obnam from the source tree, ignoring any
  system-wide or user configuration and using only the configuration
  specified by the test suite itself (`--no-default-config`). Run in
  quiet mode (`--quiet`).

* `manifest`: run summain in a way that produces a useable manifest,
  which can be compared with diff with a later manifest.

Live data generation
--------------------

The simplest way to generate test live data is to just generate the
necessary number of bytes, split over some number of files. This works
for single-client scenarios.

    IMPLEMENTS GIVEN (\S+) of live data
    genbackupdata --quiet --create "$MATCH_1" "$LIVEDATA"

We also need to generate a sparse file. A sparse file has at least one
hole in it, and it may matter where the hole is: at the beginning,
middle, or end of the file. Thus, we provide a way for scenarios to
specify that.

    IMPLEMENTS GIVEN a file (\S+) in live data, with (.+)
    mkdir -p "$LIVEDATA"
    "$SRCDIR/mksparse" "$LIVEDATA/$MATCH_1" "$MATCH_2"

Create some _interesting_ data, using the `mkfunnyfarm` utility.
See the utility for details, but this is about creating files and
other filesystem objects that are not the most common easy cases for
backup programs (regular files with data and no holes).

    IMPLEMENTS GIVEN live data with interesting filesystem objects
    "$SRCDIR/mkfunnyfarm" "$LIVEDATA"

Manifest creation and checking
------------------------------

We make it explicit in the scenario when a manifest is generated, so
that naming of the manifest is explicit. This reduces the need to
debug weird test suite bugs, when an automatic or implicit manifest
naming goes wrong.

    IMPLEMENTS GIVEN a manifest of directory (\S+) in (\S+)
    manifest "$DATADIR/$MATCH_1" > "$DATADIR/$MATCH_2"

We have not, however, made it explicit where the user's live data is,
so we have another rule for that.

    IMPLEMENTS GIVEN a manifest of live data in (\S+)
    manifest "$LIVEDATA" > "$DATADIR/$MATCH_1"

We need to check a directory tree against an existing manifest. We do
this by generating a temporary manifest and diffing against that. We
store the temporary manifest in a file so that if things fail, we can
see what the temporary manifest actually contains. Being able to look
at the actual file is easier than trying to interpret complicated
diffs.

    IMPLEMENTS THEN live data, restored to (\S+), matches manifest (\S+)
    manifest "$DATADIR/$MATCH_1/$LIVEDATA" > "$DATADIR/temp-manifest"
    diff -u "$DATADIR/$MATCH_2" "$DATADIR/temp-manifest"
    rm -f "$DATADIR/temp-manifest"

Backing up
----------

The simplest way to run a backup, for single-client scenarios. In
addition to backing up, this makes a manifest of the data.

    IMPLEMENTS WHEN user backs up live data
    run_obnam backup -r "$REPO" "$LIVEDATA"

fsck'ing a repository
---------------------

Verify that the repository itself is OK, by running `obnam fsck` on
it.

    IMPLEMENTS THEN user can fsck the repository
    run_obnam fsck -r "$REPO"

Restoring data
--------------

We need a way to restore data from a test backup repository.

    IMPLEMENTS WHEN user restores their latest generation into (\S+)
    run_obnam restore -r "$REPO" --to "$DATADIR/$MATCH_1"

Restore a specific generation. The generation number is an ordinal in
the list of generations, not the "generation id" Obnam assigns, as
that is unpredictable.

    IMPLEMENTS WHEN user restores generation (\d+) to (\S+)
    id=$(run_obnam -r "$REPO" genids | awk -v "n=$MATCH_1" 'NR == n')
    run_obnam restore -r "$REPO" --to "$DATADIR/$MATCH_2" --generation "$id"

Checks on files
---------------

Check that a restored file uses at most as much disk space as the
original one in live data.

    IMPLEMENTS THEN restored file (\S+) in (\S+) doesn't use more disk
    old=$(stat -c %b "$LIVEDATA/$MATCH_1")
    new=$(stat -c %b "$DATADIR/$MATCH_2/$LIVEDATA/$MATCH_1")
    test "$old" -lt "$new"

Check on user group membership
------------------------------

Some tests, such as those for the FUSE plugin, require the user to be
in a specific group.

    IMPLEMENTS ASSUMING user is in group (\S+)
    groups | tr ' ' '\n' | grep -Fx "$MATCH_1"
