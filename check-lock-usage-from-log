#!/usr/bin/python
# Copyright 2012  Lars Wirzenius
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


'''Check lock file usage from log files.

This program reads a number of Obnam log files, produced with tracing
for obnamlib, and analyses them for bugs when using lock files. Each
log file is assumed to be produced by a separate Obnam instance.

* Have any instances held the same lock during overlapping periods?

'''


import cliapp
import logging
import re
import time
import ttystatus


lock_pat = re.compile(
    r'vfs_local.py:[0-9]*:lock: got lockname=(?P<lock>.*)')
unlock_pat = re.compile(
    r'vfs_local.py:[0-9]*:unlock: lockname=(?P<lock>.*)')

lock_time_pat = re.compile(
    r'vfs_local.py:[0-9]*:lock: time=(?P<time>.*)')
unlock_time_pat = re.compile(
    r'vfs_local.py:[0-9]*:unlock: time=(?P<time>.*)')

writefile_pat = re.compile(
    r'vfs_local.py:[0-9]*:write_file: write_file (?P<filename>.*)$')
overwritefile_pat = re.compile(
    r'vfs_local.py:[0-9]*:overwrite_file: overwrite_file (?P<filename>.*)$')

timestamp_pat = re.compile(
    r'^(?P<timestamp>\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d)')


class LogEvent(object):

    def __init__(self, logfile, lineno, line):
        self.logfile = logfile
        self.lineno = lineno
        self.timestamp = None

    def sortkey(self):
        return self.timestamp


class LockEvent(LogEvent):

    def __init__(self, logfile, lineno, line, lockname):
        LogEvent.__init__(self, logfile, lineno, line)
        self.lockname = lockname

    def __str__(self):
        return 'Lock(%s)' % self.lockname
    

class UnlockEvent(LockEvent):

    def __str__(self):
        return 'Unlock(%s)' % self.lockname


class WriteFileEvent(LogEvent):

    def __init__(self, logfile, lineno, line, filename):
        LogEvent.__init__(self, logfile, lineno, line)
        self.filename = filename

    def __str__(self):
        return 'WriteFile(%s)' % self.filename


class OverwriteFileEvent(WriteFileEvent):

    def __str__(self):
        return 'OverwriteFile(%s)' % self.filename
    
   
class CheckLocks(cliapp.Application):

    def setup(self):
        self.events = []
        self.errors = 0
        self.latest_lock_timestamp = 0
        
        self.patterns = [
            (lock_pat, self.lock_event),
            (unlock_pat, self.unlock_event),
            (lock_time_pat, self.set_latest_lock_precise_time),
            (unlock_time_pat, self.set_latest_unlock_precise_time),
            (writefile_pat, self.writefile_event),
            (overwritefile_pat, self.overwritefile_event),
        ]
        
        self.ts = ttystatus.TerminalStatus()
        self.ts.format(
            'Reading %ElapsedTime() %Integer(lines): %Pathname(filename)')
        self.ts['lines'] = 0
        
    def cleanup(self):
        self.ts.clear()

        self.analyse_phase_1()

        self.ts.finish()
        if self.errors:
            raise cliapp.AppException('There were %d errors' % self.errors)

    def error(self, msg):
        logging.error(msg)
        self.ts.error(msg)
        self.errors += 1

    def analyse_phase_1(self):
        self.events.sort(key=lambda e: e.sortkey())
        self.ts.format('Phase 1: %Index(event,events)')
        self.ts['events'] = self.events
        self.ts.flush()

        current_locks = set()
        for e in self.events:
            self.ts['event'] = e
            logging.debug(
                'analysing: %s:%s: %s: %s' % 
                    (e.logfile, e.lineno, e.sortkey(), str(e)))
            if type(e) is LockEvent:
                if e.lockname in current_locks:
                    self.error(
                        'Re-locking %s: %s:%s:%s' % 
                            (e.lockname, e.logfile, e.lineno, 
                             e.timestamp))
                else:
                    current_locks.add(e.lockname)
            elif type(e) is UnlockEvent:
                if e.lockname not in current_locks:
                    self.error(
                        'Unlocking %s which was not locked: %s:%s:%s' %
                            (e.lockname, e.logfile, e.lineno,
                             e.timestamp))
                else:
                    current_locks.remove(e.lockname)
            elif type(e) in (WriteFileEvent, OverwriteFileEvent):
                lockname = self.determine_lockfile(e.filename)
                if lockname and lockname not in current_locks:
                    self.error(
                        '%s:%s: '
                        'Write to file %s despite lock %s not existing' %
                            (e.logfile, e.lineno, e.filename, lockname))
            else:
                raise NotImplementedError()

    def determine_lockfile(self, filename):
        if filename.endswith('/lock'):
            return None
        toplevel = filename.split('/')[0]
        if toplevel == 'chunks':
            return None
        if toplevel in ('metadata', 'clientlist'):
            return './lock'
        return toplevel + '/lock'

    def process_input(self, name):
        self.ts['filename'] = name
        return cliapp.Application.process_input(self, name)

    def process_input_line(self, filename, line):
        self.ts['lines'] = self.global_lineno
        for pat, func in self.patterns:
            m = pat.search(line)
            if m:
                event = func(filename, line, m)
                if event is not None:
                    self.events.append(event)

    def lock_event(self, filename, line, match):
        return LockEvent(filename, self.lineno, line, match.group('lock'))

    def unlock_event(self, filename, line, match):
        return UnlockEvent(filename, self.lineno, line, match.group('lock'))

    def set_latest_lock_precise_time(self, filename, line, match):
        event = self.events[-1]
        assert type(event) is LockEvent
        assert event.timestamp is None
        event.timestamp = match.group('time')
        self.latest_lock_timestamp = event.timestamp

    def set_latest_unlock_precise_time(self, filename, line, match):
        event = self.events[-1]
        assert type(event) is UnlockEvent
        assert event.timestamp is None
        event.timestamp = match.group('time')
        self.latest_lock_timestamp = event.timestamp

    def writefile_event(self, filename, line, match):
        e = WriteFileEvent(
            filename, self.lineno, line, match.group('filename'))
        e.timestamp = self.latest_lock_timestamp
        return e

    def overwritefile_event(self, filename, line, match):
        e = OverwriteFileEvent(
            filename, self.lineno, line, match.group('filename'))
        e.timestamp = self.latest_lock_timestamp
        return e


CheckLocks().run()

